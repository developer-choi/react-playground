@use "/src/styles/util";
@use "/src/styles/color";

/**
 * class로 경우에따라 loading 지정 필요
 */
@mixin cursorByState {
  // cursor by state
  cursor: pointer;
  
  &.loading {
    cursor: progress;
  }
  
  :disabled {
    cursor: not-allowed;
  }
}

@mixin textByButtonSize($size) {
  $style: (
    large: (
      padding: 11px 33px,
      font-size: 16px,
      line-height: 24px
    ),
    medium: (
      padding: 9px 27px,
      font-size: 14px,
      line-height: 20px
    ),
    small: (
      padding: 3px 9px,
      font-size: 12px,
      line-height: 16px
    ),
  );
  
  padding: util.safeMapGet(util.safeMapGet($style, $size), padding);
  font-size: util.safeMapGet(util.safeMapGet($style, $size), font-size);
  line-height: util.safeMapGet(util.safeMapGet($style, $size), line-height);
};

/**
 * class로 경우에따라 large / medium 지정 필요
 */
@mixin buttonSize {
  border: {
    width: 1px;
    style: solid;
    radius: 2px;
  }
  @each $size in large, medium, small {
    &.#{$size} {
      @include textByButtonSize($size);
    }
  }
}

@mixin loadingColor($color) {
  svg > circle {
    stroke: $color;
  }
}

/**
 * @param variant outlined / contained
 * @param colorOrState disabled / primary / secondary
 */
@mixin colorSet($variant, $colorOrState) {
  //  disabled 상태인 경우 강제로 contained 적용
  @if $colorOrState == 'disabled' {
    $pointerColor: white;
    @include loadingColor($pointerColor);
    border-color: util.safeMapGet(color.$stateColors, disabled);
    background-color: util.safeMapGet(color.$stateColors, disabled);
    color: $pointerColor;
  }
  
  @else {
    $pointerColor: util.safeMapGet(color.$brandColors, $colorOrState);
    $color: if($variant == 'contained', white, $pointerColor);
    
    @include loadingColor($color);
    border-color: $pointerColor;
    background-color: if($variant == 'contained', $pointerColor, white);
    color: $color;
  }
}

/**
 * class로 경우에따라
 * 1. outlined / contained 지정 필요
 * 2. primary / secondary 지정 필요
 */
@mixin buttonColorSet {
  @each $color in primary, secondary {
    @each $variant in outlined, contained {
      &.#{$color}.#{$variant} {
        @include colorSet($variant, $color);
      }
      
      &.#{$color}.#{$variant}:disabled {
        @include colorSet(contained, disabled);
      }
    }
  }
}

.button {
  // 추가로 필요한 클래스이름은 하단 mixin 주석 참고
  @include cursorByState;
  @include buttonSize;
  @include buttonColorSet;
  
  // flex-shrink: 0; button 공통스타일에 이런속성 쓰면 안됨. 인풋, 버튼이 한줄로 있는 케이스에서나 통하지 버튼 2개이상 있는 케이스에서는 오히려 안됨.
  position: relative; // 로딩을 absolute로 만들기 위해
  
  // [Button (Markup)] https://docs.google.com/document/d/1aEHPwWUlT8nLpzuJwogzQerYawVbWIk8WCMRaxleDaI/edit
  &:global(.submit) {
    width: 100%;
    margin-top: 24px;
  }
  
  &:global(.full) {
    width: 100%;
  }
}

.buttonLink {
  // button의 기본 스타일이지만, anchor는 없으므로 별도 추가
  text-align: center;
  display: inline-block;
}

.childrenContainer {
  width: 100%;
  height: 100%;
  
  /**
     * 버튼에 텍스트만 있는경우 브라우저의 버튼 기본스타일로 수직 수평정렬이 가능하지만,
     * 버튼안에 아이콘 또는 아이콘+텍스트가 들어가는 케이스때문에 이렇게 설정해야.
     */
  @include util.flexCenter;
  display: inline-flex;
  
  /**
     * 버튼텍스트가 길어지는경우 대응.
     * 텍스트가 버튼 크기보다 길 경우, 두세줄 되면서 버튼 높이 커지고 그에따라 레이아웃이 틀어지는 현상을 막기위함.
     * 이렇게 하면, UI 오류가 버튼에만 발생하고 옆 UI에 영향을 주지않음.
     */
  white-space: nowrap;
  overflow: hidden;
  
  column-gap: 4px; // 아이콘, 텍스트 사이 간격은 디자인 시스템에 따름.
  
  &.loading {
    visibility: hidden;
  }
  
  // 버튼에 어떠한 크기, 모양의 아이콘이 오더라도 아래 스타일 적용하도록 디자이너와 협의됨
  > svg:not(.loadingSpinner), img {
    width: auto;
    height: 16px;
    border-radius: 2px;
  }
}

.loadingSpinner {
  @include util.absoluteCenter;
}

.imageWrapper {
  display: inline-block;
  font-size: 0;
  
  // 이미지가 container로 오는 <img나 <button을 뚫고 나가지 못하게 수정
  > img {
    width: 100%;
    height: auto;
  }
}
